{"version":3,"sources":["script.js"],"names":["App","init","this","boardDimension","board","Array","fill","undefined","MIN","moveAndGetUtil","bind","MAX","turnInformer","randomRange","restartPauseDuration","boardToOut","makeMove","drawCell","arguments","length","utility","computerMove","then","nextMove","_this","terminal","chooseMove","handleTerminalConditions","condition","_this2","log","debug","msg","showMessage","stopListenElms","boardElm","resetBoard","i","toOut","slice","elm","join","console","whoseTurn","player","info","arr","Math","floor","random","Engine","start","actions","getBestDebutMoves","logDepth","logLine","minimax","move","depth","_this3","_utility","_utility2","_slicedToArray","newBoard","apply","map","min","col","row","y","ceil","playerInColumn","playerInRow","x","playerInDiag","z","movesDone","reduce","movesLeft","nextMoveArr","res","acc","ndx","push","availableMoves","JSON","stringify","includes","suggestedMove","_this4","Promise","resolve","filter","maxUtility","max","symbolChoiceHandler","handleClick","frmSymbolChoice","document","boardCells","msgElm","querySelector","UI","listen","data","drawBoard","addElm","changeActiveStyle","initializeBoard","documentElement","style","setProperty","removeEventListener","querySelectorAll","host","innerHTML","e","_this5","FormData","forEach","childNodes","child","currentTarget","boardHTML","_this6","classList","toggle","addEventListener","_this7","cell","value","type","handleBoardClick","id","split","Boolean","remove","add","clearMessage","setLevel","Object","assign"],"mappings":"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","file":"script.js","sourcesContent":["/* eslint no-var: 0 */\n/* eslint vars-on-top: 0 */\n/* eslint prefer-const: 0 */\n/* eslint arrow-parens: 0 */\n/* eslint consistent-return: 0 */\n\n// +(engine) add terminal conditions handler;\n// +(engine) add start game routine - if the user have chosen 0, then comp should start;\n// +(engine) add start game shortcuts - no need to run after first user move (to long);\n// +(engine) start engine in async to UI;\n// +(engine) check whether anti-diag analysis actially works;\n// +(engine) fix halting when player starts from the center;\n// (UI) add flag - which turn is now;\n// +(UI) add symbol choice dialog;\n// (UI) add game ending message;\n// +(UI) stop the game after terminal condition is reached;\n// +(UI - minor) remove event handler on already clicked cell;\n// +(UI) when the game is finished, wait and start it again;\n\n// minimax(board, player  ) recursive;\n// ev(board, player) - evaluation function - value of a position for the player;\n// winning(board) - returns boolean and player dependent on the position;\n// mapToInt(board, player) - convert player position to 0&1 representation;\n// getMoveNumber(board) - return number of the moves done;\n\n/*\nThe board is an array with available states: '0', 'X' and undefined;\nThe game logic is:\n  - render the board;\n  - render the turn choice;\n  - chooseMove() on the next turn move;\n  - makeMove() to get the new board;\n  - render the changes on the board;\n  - analyze whether we have terminal conditions:\n    - YES - stop the game; show the message;\n    - NO - keep playing;\n*/\n\nvar App = {\n  init() {\n    this.boardDimension = 3;\n    this.board = new Array(this.boardDimension * this.boardDimension).fill(\n      undefined,\n    );\n    this.MAX = '0'; // computer player;\n    this.MIN = 'X'; // interactive player;\n    this.restartPauseDuration = 2; // in seconds;\n    this.moveAndGetUtil = this.moveAndGetUtil.bind(this);\n    this.turnInformer = this.turnInformer.bind(this);\n    this.randomRange = this.randomRange.bind(this);\n    this.boardToOut = this.boardToOut.bind(this);\n  },\n\n  moveAndGetUtil(...args) {\n    this.board = this.makeMove(...args);\n    this.drawCell(args[1], args[2]);\n    return this.utility(...args);\n  },\n\n  computerMove() {\n    this.turnInformer(this.board);\n    this.chooseMove(this.board)\n      .then(nextMove => this.moveAndGetUtil(this.board, nextMove, this.MAX))\n      .then(terminal => {\n        if (terminal[0]) this.handleTerminalConditions(terminal[1]);\n        else this.turnInformer(this.board);\n      });\n  },\n\n  handleTerminalConditions(condition) {\n    log.debug(`handleTerminalConditions got condition: ${condition}`);\n    var msg = '';\n    if (condition === -1) {\n      msg = 'You win!';\n      this.showMessage(msg);\n    } else if (condition === 1) {\n      msg = 'Computer wins!';\n      this.showMessage(msg);\n    } else if (condition === 0) {\n      msg = 'Draw!';\n      this.showMessage(msg);\n    }\n    this.stopListenElms(this.boardElm);\n    window.setTimeout(() => {\n      this.clearMessage();\n      this.resetBoard();\n    }, this.restartPauseDuration * 1000);\n  },\n\n  resetBoard() {\n    log.debug('resetBoard started');\n    this.board = new Array(this.boardDimension * this.boardDimension).fill(\n      undefined,\n    );\n    this.drawBoard(this.board);\n    // this.changeActiveStyle(this.MIN);\n    if (this.MAX === 'X') this.computerMove();\n  },\n\n  boardToOut(board) {\n    for (var i = 0; i < this.boardDimension; i++) {\n      var toOut = board\n        .slice(i * this.boardDimension, (i + 1) * this.boardDimension)\n        .map(elm => (elm ? elm : '_'))\n        .join(' ');\n      console.log(toOut);\n    }\n  },\n\n  turnInformer(board) {\n    var whoseTurn = this.player(board);\n    if (whoseTurn === this.MAX) {\n      log.info('Computer turn');\n      // this.changeActiveStyle(this.MAX);\n    } else {\n      log.info('Player turn');\n      // this.changeActiveStyle(this.MIN);\n    }\n  },\n\n  randomRange(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  },\n};\n\nvar Engine = {\n  start() {\n    this.minimax = this.minimax.bind(this);\n    this.utility = this.utility.bind(this);\n    this.player = this.player.bind(this);\n    this.actions = this.actions.bind(this);\n    this.makeMove = this.makeMove.bind(this);\n    this.getBestDebutMoves = this.getBestDebutMoves.bind(this);\n    this.chooseMove = this.chooseMove.bind(this);\n    this.logDepth = this.logDepth.bind(this);\n    this.debug = 0;\n    this.logLine = 1;\n  },\n\n  minimax(board, move, player, depth) {\n    depth = depth || 0;\n    var [terminal, utility] = this.utility(board, move, player);\n    if (terminal) {\n      this.logDepth(depth, 'utility', utility);\n      return utility;\n    }\n    var newBoard = this.makeMove(board, move, player);\n    if (this.player(newBoard) === this.MAX) {\n      this.logDepth(++depth, 'turn', this.MAX);\n      return Math.max.apply(\n        null,\n        this.actions(newBoard).map(nextMove => {\n          this.logDepth(depth, 'move', nextMove);\n          return this.minimax(newBoard, nextMove, this.MAX, depth);\n        }),\n      );\n    }\n    if (this.player(newBoard) === this.MIN) {\n      this.logDepth(++depth, 'turn', this.MIN);\n      return Math.min.apply(\n        null,\n        this.actions(newBoard).map(nextMove => {\n          this.logDepth(depth, 'move', nextMove);\n          return this.minimax(newBoard, nextMove, this.MIN, depth);\n        }),\n      );\n    }\n  },\n\n  utility(board, move, player) {\n    // terminal conditions are draw or win;\n    // if diag or anti-diag or any row or col filled with same symbols - win;\n    // if no more turns left - draw;\n\n    var newBoard = this.makeMove(board, move, player);\n    // log.debug(this.boardToOut(newBoard));\n\n    var row = Math.ceil((move + 1) / this.boardDimension) - 1;\n    var col = move % this.boardDimension;\n    // analyze column where move takes place;\n    var playerInColumn = 0;\n    for (let y = 0; y < this.boardDimension; y++) {\n      if (newBoard[y * this.boardDimension + col] === player) {\n        playerInColumn += 1;\n      }\n    }\n    if (playerInColumn === this.boardDimension && player === this.MAX)\n      return [true, 1];\n    else if (playerInColumn === this.boardDimension && player === this.MIN)\n      return [true, -1];\n    // analyze row where move takes place;\n    var playerInRow = 0;\n    for (let x = 0; x < this.boardDimension; x++) {\n      if (newBoard[row * this.boardDimension + x] === player) {\n        playerInRow += 1;\n      }\n    }\n    if (playerInRow === this.boardDimension && player === this.MAX)\n      return [true, 1];\n    else if (playerInRow === this.boardDimension && player === this.MIN)\n      return [true, -1];\n\n    if (row === col) {\n      // analyze diag where move takes place;\n      var playerInDiag = 0;\n      for (let z = 0; z < this.boardDimension; z++) {\n        if (newBoard[z + this.boardDimension * z] === player) {\n          playerInDiag += 1;\n        }\n      }\n      if (playerInDiag === this.boardDimension && player === this.MAX)\n        return [true, 1];\n      else if (playerInDiag === this.boardDimension && player === this.MIN)\n        return [true, -1];\n    }\n\n    if (row === this.boardDimension - col - 1) {\n      var playerInDiag = 0;\n      // analyze anti-diag where move takes place;\n      for (let z = 0; z < this.boardDimension; z++) {\n        if (\n          newBoard[(this.boardDimension - z) * (this.boardDimension - 1)] ===\n          player\n        ) {\n          playerInDiag += 1;\n        }\n      }\n      if (playerInDiag === this.boardDimension && player === this.MAX)\n        return [true, 1];\n      else if (playerInDiag === this.boardDimension && player === this.MIN)\n        return [true, -1];\n    }\n\n    if (!this.actions(newBoard)) return [true, 0];\n\n    return [undefined, undefined];\n  },\n\n  player(board) {\n    var movesDone = board.reduce((res, elm) => (elm ? res + 1 : res), 0);\n    return movesDone % 2 === 0 ? 'X' : '0';\n  },\n\n  actions(board) {\n    var movesLeft = board.reduce((acc, elm, ndx) => {\n      if (!elm) acc.push(ndx);\n      return acc;\n    }, []);\n    return movesLeft.length > 0 ? movesLeft : undefined;\n  },\n\n  makeMove(board, move, player) {\n    var newBoard = [...board];\n    newBoard[move] = player;\n    return newBoard;\n  },\n\n  getBestDebutMoves(availableMoves) {\n    var nextMoveArr = [];\n    nextMoveArr.push(0);\n    nextMoveArr.push(this.boardDimension - 1);\n    nextMoveArr.push(this.board.length - this.boardDimension);\n    nextMoveArr.push(this.board.length - 1);\n    if (this.boardDimension % 2 !== 0) {\n      nextMoveArr.push((this.board.length - 1) / 2);\n    }\n    log.debug(`All available debut moves: ${JSON.stringify(nextMoveArr)}`);\n    nextMoveArr = nextMoveArr.filter(elm => availableMoves.includes(elm));\n    return this.randomRange(nextMoveArr);\n  },\n\n  chooseMove(board) {\n    return new Promise(resolve => {\n      var nextMove;\n      var availableMoves = this.actions(this.board);\n      // if computer starts, then put 'X' either to center or to any corner;\n      if (availableMoves.length === this.board.length) {\n        nextMove = this.getBestDebutMoves(availableMoves);\n      } else if (availableMoves.length === this.board.length - 1) {\n        // if a player starts, then put 'X' to center if available or to any corner;\n        log.debug(`We are on the second move routine, choosing for next move`);\n\n        nextMove = this.getBestDebutMoves(availableMoves);\n        log.debug(`Preliminary chosen move: ${nextMove}`);\n\n        if (this.boardDimension % 2 !== 0) {\n          var suggestedMove = (this.board.length - 1) / 2;\n          log.debug(`Available moves are: ${JSON.stringify(availableMoves)}`);\n          if (availableMoves.includes(suggestedMove)) nextMove = suggestedMove;\n        }\n      } else {\n        // if game is in the middle, then enumerate available moves and\n        // call minimax for each, to find the best;\n        availableMoves = this.actions(board).map(move => {\n          var utility = this.minimax(board, move, this.MAX);\n          return [move, utility];\n        });\n        log.debug(`Available moves: ${JSON.stringify(availableMoves)}`);\n        // if more than one move available at max utility, choose any of them.\n        var maxUtility = Math.max.apply(\n          null,\n          availableMoves.map(elm => elm[1]),\n        );\n        log.debug(`Max utility: ${maxUtility}`);\n        // if more than one move available at max utility, choose any of them.\n        availableMoves = availableMoves.filter(elm => elm[1] === maxUtility);\n        log.debug(\n          `Available moves after max filter: ${JSON.stringify(availableMoves)}`,\n        );\n        nextMove = this.randomRange(availableMoves)[0];\n      }\n      resolve(nextMove);\n    });\n  },\n\n  logDepth(depth, ...args) {\n    if (this.debug === 9) {\n      console.log(\n        `${this.logLine++}. ${depth}${new Array(depth * 2).fill('-').join('')}${\n          args[0]\n        }: ${args[1]}`,\n      );\n    }\n  },\n};\n\nvar UI = {\n  listen() {\n    log.debug(`UI listen called`);\n    this.drawBoard = this.drawBoard.bind(this);\n    this.drawCell = this.drawCell.bind(this);\n    this.symbolChoiceHandler = this.symbolChoiceHandler.bind(this);\n    this.addElm = this.addElm.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.changeActiveStyle = this.changeActiveStyle.bind(this);\n    this.showMessage = this.showMessage.bind(this);\n    this.clearMessage = this.clearMessage.bind(this);\n    this.frmSymbolChoice = document.querySelector('#frmSymbolChoice');\n    this.frmSymbolChoice.removeEventListener(\n      'change',\n      this.symbolChoiceHandler,\n    );\n    this.frmSymbolChoice.addEventListener('change', this.symbolChoiceHandler);\n    this.boardElm = document.querySelector('#boardElm');\n    this.boardCells = document.querySelectorAll('.board__cell');\n    this.msgElm = document.querySelector('#msgElm');\n    this.initializeBoard();\n    this.drawBoard(this.board);\n  },\n\n  symbolChoiceHandler(e) {\n    log.debug(e);\n    // e.preventDefault();\n    var data = new FormData(this.frmSymbolChoice);\n    data.forEach(elm => {\n      log.debug(`User's choise: ${elm}`);\n      this.MIN = elm;\n      this.MAX = this.MIN === 'X' ? '0' : 'X';\n    });\n    this.resetBoard();\n  },\n\n  initializeBoard() {\n    document.documentElement.style.setProperty(\n      '--boardDimension',\n      this.boardDimension,\n    );\n  },\n\n  drawBoard(board) {\n    var boardHTML = board\n      .map((elm, ndx) => {\n        return `<div class=\"board__cell\" id=\"boardCellElm_${ndx}\">\n                  <span>${elm || ''}</span>\n                </div>`;\n      })\n      .join('');\n    this.addElm(this.boardElm, boardHTML);\n  },\n\n  addElm(host, elm) {\n    host.innerHTML = elm;\n    host.childNodes.forEach(child =>\n      child.addEventListener('click', this.handleClick),\n    );\n  },\n\n  stopListenElms(host) {\n    host.childNodes.forEach(child =>\n      child.removeEventListener('click', this.handleClick),\n    );\n  },\n\n  drawCell(cell, value) {\n    var cellElm = document.querySelector(`#boardCellElm_${cell}`);\n    cellElm.innerHTML = value;\n  },\n\n  handleClick(e) {\n    e.currentTarget.removeEventListener(e.type, this.handleBoardClick);\n    log.debug(`Player clicked ${e.currentTarget.id}`);\n    var move = e.currentTarget.id.split('_')[1];\n\n    if (!this.board[move]) {\n      var terminal = this.moveAndGetUtil(this.board, move, this.MIN);\n      log.debug(\n        `Condition after move to ${move} is ${\n          Boolean(terminal[0]) ? 'terminal' : 'non-terminal'\n        }`,\n      );\n\n      if (terminal[0]) this.handleTerminalConditions(terminal[1]);\n      else this.computerMove();\n    }\n  },\n\n  changeActiveStyle(player) {\n    document\n      .querySelector(`#label${player === 'X' ? '0' : 'X'}`)\n      .classList.remove('menu__element--active');\n    document\n      .querySelector(`#label${player}`)\n      .classList.add('menu__element--active');\n  },\n\n  showMessage(msg) {\n    log.info(msg);\n    this.msgElm.innerHTML = msg;\n    this.msgElm.classList.toggle('--hidden');\n  },\n\n  clearMessage() {\n    this.msgElm.innerHTML = '';\n    this.msgElm.classList.toggle('--hidden');\n  },\n};\n\nlog.setLevel('info');\nObject.assign(App, UI, Engine);\nApp.init();\nApp.listen();\nApp.start();\n\n/* 3x3 board\n0 1 2\n3 4 5\n6 7 8\n*/\nApp.drawBoard(App.board);\n\n/* 4x4 board with a row and diag filled\n0 1 2 3\n4 5 6 7\n8 9 0 1\n2 3 4 5\n*/\n"],"sourceRoot":"/source/"}
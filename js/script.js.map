{"version":3,"sources":["script.js"],"names":["App","init","this","boardDimension","board","Array","fill","undefined","MIN","moveAndGetUtil","bind","MAX","turnInformer","randomRange","restartPauseDuration","boardToOut","makeMove","utility","computerMove","then","nextMove","_this","terminal","chooseMove","handleTerminalConditions","condition","_this2","log","debug","info","boardElm","window","stopListenElms","setTimeout","resetBoard","drawBoard","join","i","console","toOut","slice","map","elm","whoseTurn","Math","player","minimax","floor","random","arr","length","Engine","start","getBestDebutMoves","logDepth","logLine","actions","depth","move","_this3","_utility","_utility2","_slicedToArray","newBoard","apply","min","row","y","col","ceil","playerInColumn","playerInRow","x","z","playerInDiag","res","movesLeft","ndx","nextMoveArr","push","reduce","acc","availableMoves","suggestedMove","filter","includes","_this4","maxUtility","JSON","stringify","max","symbolChoiceHandler","frmSymbolChoice","resolve","document","boardCells","initializeBoard","arguments","UI","data","drawCell","addElm","handleClick","querySelector","documentElement","addEventListener","host","childNodes","forEach","e","_this5","FormData","cellElm","innerHTML","style","setProperty","boardHTML","_this6","child","_this7","removeEventListener","cell","value","currentTarget","type","handleBoardClick","id","split","Boolean","Object","assign","listen"],"mappings":"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","file":"script.js","sourcesContent":["/* eslint no-var: 0 */\n/* eslint vars-on-top: 0 */\n/* eslint prefer-const: 0 */\n/* eslint arrow-parens: 0 */\n/* eslint consistent-return: 0 */\n\n// +(engine) add terminal conditions handler;\n// +(engine) add start game routine - if the user have chosen 0, then comp should start;\n// +(engine) add start game shortcuts - no need to run after first user move (to long);\n// (engine) start engine in async to UI;\n// +(engine) check whether anti-diag analysis actially works;\n// +(engine) fix halting when player starts from the center;\n// (UI) add flag - which turn is now;\n// (UI) add symbol choice dialog;\n// (UI) add game ending message;\n// (UI) stop the game after terminal condition is reached;\n// +(UI - minor) remove event handler on already clicked cell;\n// (UI) when the game is finished, wait and start it again;\n\n// minimax(board, player  ) recursive;\n// ev(board, player) - evaluation function - value of a position for the player;\n// winning(board) - returns boolean and player dependent on the position;\n// mapToInt(board, player) - convert player position to 0&1 representation;\n// getMoveNumber(board) - return number of the moves done;\n\n/*\nThe board is an array with available states: '0', 'X' and undefined;\nThe game logic is:\n  - render the board;\n  - render the turn choice;\n  - chooseMove() on the next turn move;\n  - makeMove() to get the new board;\n  - render the changes on the board;\n  - analyze whether we have terminal conditions:\n    - YES - stop the game; show the message;\n    - NO - keep playing;\n*/\n\nvar App = {\n  init() {\n    this.boardDimension = 3;\n    this.board = new Array(this.boardDimension * this.boardDimension).fill(\n      undefined,\n    );\n    this.MAX = '0'; // computer player;\n    this.MIN = 'X'; // interactive player;\n    this.restartPauseDuration = 3; // in seconds;\n    this.moveAndGetUtil = this.moveAndGetUtil.bind(this);\n    this.turnInformer = this.turnInformer.bind(this);\n    this.randomRange = this.randomRange.bind(this);\n    this.boardToOut = this.boardToOut.bind(this);\n  },\n\n  moveAndGetUtil(...args) {\n    this.board = this.makeMove(...args);\n    // this.drawBoard(this.board); // replace with drawCell();\n    this.drawCell(args[1], args[2]);\n    return this.utility(...args);\n  },\n\n  computerMove() {\n    this.turnInformer(this.board);\n    this.chooseMove(this.board)\n      .then(nextMove => this.moveAndGetUtil(this.board, nextMove, this.MAX))\n      .then(terminal => {\n        if (terminal[0]) this.handleTerminalConditions(terminal[1]);\n        else this.turnInformer(this.board);\n      });\n  },\n\n  handleTerminalConditions(condition) {\n    log.debug(`handleTerminalConditions got condition: ${condition}`);\n    if (condition === -1) log.info('You win!');\n    else if (condition === 1) log.info('Computer wins!');\n    else if (condition === 0) log.info('Draw!');\n    this.stopListenElms(this.boardElm);\n    window.setTimeout(\n      () => this.resetBoard(),\n      this.restartPauseDuration * 1000,\n    );\n  },\n\n  resetBoard() {\n    log.debug('resetBoard started');\n    // var player = this.MIN;\n    // this.init();\n    // this.listen();\n    this.board = new Array(this.boardDimension * this.boardDimension).fill(\n      undefined,\n    );\n    this.drawBoard(this.board);\n    // this.MIN = player;\n    // this.MAX = this.MIN === 'X' ? '0' : 'X';\n    if (this.MAX === 'X') this.computerMove();\n  },\n\n  boardToOut(board) {\n    for (var i = 0; i < this.boardDimension; i++) {\n      var toOut = board\n        .slice(i * this.boardDimension, (i + 1) * this.boardDimension)\n        .map(elm => (elm ? elm : '_'))\n        .join(' ');\n      console.log(toOut);\n    }\n  },\n\n  turnInformer(board) {\n    var whoseTurn = this.player(board);\n    if (whoseTurn === this.MAX) log.info('Computer turn');\n    else log.info('Player turn');\n  },\n\n  randomRange(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  },\n};\n\nvar Engine = {\n  start() {\n    this.minimax = this.minimax.bind(this);\n    this.utility = this.utility.bind(this);\n    this.player = this.player.bind(this);\n    this.actions = this.actions.bind(this);\n    this.makeMove = this.makeMove.bind(this);\n    this.getBestDebutMoves = this.getBestDebutMoves.bind(this);\n    this.chooseMove = this.chooseMove.bind(this);\n    this.logDepth = this.logDepth.bind(this);\n    this.debug = 0;\n    this.logLine = 1;\n  },\n\n  minimax(board, move, player, depth) {\n    depth = depth || 0;\n    var [terminal, utility] = this.utility(board, move, player);\n    if (terminal) {\n      this.logDepth(depth, 'utility', utility);\n      return utility;\n    }\n    var newBoard = this.makeMove(board, move, player);\n    if (this.player(newBoard) === this.MAX) {\n      this.logDepth(++depth, 'turn', this.MAX);\n      return Math.max.apply(\n        null,\n        this.actions(newBoard).map(nextMove => {\n          this.logDepth(depth, 'move', nextMove);\n          return this.minimax(newBoard, nextMove, this.MAX, depth);\n        }),\n      );\n    }\n    if (this.player(newBoard) === this.MIN) {\n      this.logDepth(++depth, 'turn', this.MIN);\n      return Math.min.apply(\n        null,\n        this.actions(newBoard).map(nextMove => {\n          this.logDepth(depth, 'move', nextMove);\n          return this.minimax(newBoard, nextMove, this.MIN, depth);\n        }),\n      );\n    }\n  },\n\n  utility(board, move, player) {\n    // terminal conditions are draw or win;\n    // if diag or anti-diag or any row or col filled with same symbols - win;\n    // if no more turns left - draw;\n\n    var newBoard = this.makeMove(board, move, player);\n    // log.debug(this.boardToOut(newBoard));\n\n    var row = Math.ceil((move + 1) / this.boardDimension) - 1;\n    var col = move % this.boardDimension;\n    // analyze column where move takes place;\n    var playerInColumn = 0;\n    for (let y = 0; y < this.boardDimension; y++) {\n      if (newBoard[y * this.boardDimension + col] === player) {\n        playerInColumn += 1;\n      }\n    }\n    if (playerInColumn === this.boardDimension && player === this.MAX)\n      return [true, 1];\n    else if (playerInColumn === this.boardDimension && player === this.MIN)\n      return [true, -1];\n    // analyze row where move takes place;\n    var playerInRow = 0;\n    for (let x = 0; x < this.boardDimension; x++) {\n      if (newBoard[row * this.boardDimension + x] === player) {\n        playerInRow += 1;\n      }\n    }\n    if (playerInRow === this.boardDimension && player === this.MAX)\n      return [true, 1];\n    else if (playerInRow === this.boardDimension && player === this.MIN)\n      return [true, -1];\n\n    if (row === col) {\n      // analyze diag where move takes place;\n      var playerInDiag = 0;\n      for (let z = 0; z < this.boardDimension; z++) {\n        if (newBoard[z + this.boardDimension * z] === player) {\n          playerInDiag += 1;\n        }\n      }\n      if (playerInDiag === this.boardDimension && player === this.MAX)\n        return [true, 1];\n      else if (playerInDiag === this.boardDimension && player === this.MIN)\n        return [true, -1];\n    }\n\n    if (row === this.boardDimension - col - 1) {\n      var playerInDiag = 0;\n      // analyze anti-diag where move takes place;\n      for (let z = 0; z < this.boardDimension; z++) {\n        if (\n          newBoard[(this.boardDimension - z) * (this.boardDimension - 1)] ===\n          player\n        ) {\n          playerInDiag += 1;\n        }\n      }\n      if (playerInDiag === this.boardDimension && player === this.MAX)\n        return [true, 1];\n      else if (playerInDiag === this.boardDimension && player === this.MIN)\n        return [true, -1];\n    }\n\n    if (!this.actions(newBoard)) return [true, 0];\n\n    return [undefined, undefined];\n  },\n\n  player(board) {\n    var movesDone = board.reduce((res, elm) => (elm ? res + 1 : res), 0);\n    return movesDone % 2 === 0 ? 'X' : '0';\n  },\n\n  actions(board) {\n    var movesLeft = board.reduce((acc, elm, ndx) => {\n      if (!elm) acc.push(ndx);\n      return acc;\n    }, []);\n    return movesLeft.length > 0 ? movesLeft : undefined;\n  },\n\n  makeMove(board, move, player) {\n    var newBoard = [...board];\n    newBoard[move] = player;\n    return newBoard;\n  },\n\n  getBestDebutMoves(availableMoves) {\n    var nextMoveArr = [];\n    nextMoveArr.push(0);\n    nextMoveArr.push(this.boardDimension - 1);\n    nextMoveArr.push(this.board.length - this.boardDimension);\n    nextMoveArr.push(this.board.length - 1);\n    if (this.boardDimension % 2 !== 0) {\n      nextMoveArr.push((this.board.length - 1) / 2);\n    }\n    log.debug(`All available debut moves: ${JSON.stringify(nextMoveArr)}`);\n    nextMoveArr = nextMoveArr.filter(elm => availableMoves.includes(elm));\n    return this.randomRange(nextMoveArr);\n  },\n\n  chooseMove(board) {\n    return new Promise(resolve => {\n      var nextMove;\n      var availableMoves = this.actions(this.board);\n      // if computer starts, then put 'X' either to center or to any corner;\n      if (availableMoves.length === this.board.length) {\n        nextMove = this.getBestDebutMoves(availableMoves);\n      } else if (availableMoves.length === this.board.length - 1) {\n        // if a player starts, then put 'X' to center if available or to any corner;\n        log.debug(`We are on the second move routine, choosing for next move`);\n\n        nextMove = this.getBestDebutMoves(availableMoves);\n        log.debug(`Preliminary chosen move: ${nextMove}`);\n\n        if (this.boardDimension % 2 !== 0) {\n          var suggestedMove = (this.board.length - 1) / 2;\n          log.debug(`Available moves are: ${JSON.stringify(availableMoves)}`);\n          if (availableMoves.includes(suggestedMove)) nextMove = suggestedMove;\n        }\n      } else {\n        // if game is in the middle, then enumerate available moves and\n        // call minimax for each, to find the best;\n        availableMoves = this.actions(board).map(move => {\n          var utility = this.minimax(board, move, this.MAX);\n          return [move, utility];\n        });\n        log.debug(`Available moves: ${JSON.stringify(availableMoves)}`);\n        // if more than one move available at max utility, choose any of them.\n        var maxUtility = Math.max.apply(\n          null,\n          availableMoves.map(elm => elm[1]),\n        );\n        log.debug(`Max utility: ${maxUtility}`);\n        // if more than one move available at max utility, choose any of them.\n        availableMoves = availableMoves.filter(elm => elm[1] === maxUtility);\n        log.debug(\n          `Available moves after max filter: ${JSON.stringify(availableMoves)}`,\n        );\n        nextMove = this.randomRange(availableMoves)[0];\n      }\n      resolve(nextMove);\n    });\n  },\n\n  logDepth(depth, ...args) {\n    if (this.debug === 9) {\n      console.log(\n        `${this.logLine++}. ${depth}${new Array(depth * 2).fill('-').join('')}${\n          args[0]\n        }: ${args[1]}`,\n      );\n    }\n  },\n};\n\nvar UI = {\n  listen() {\n    log.debug(`UI listen called`);\n    this.drawBoard = this.drawBoard.bind(this);\n    this.drawCell = this.drawCell.bind(this);\n    this.symbolChoiceHandler = this.symbolChoiceHandler.bind(this);\n    this.addElm = this.addElm.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.frmSymbolChoice = document.querySelector('#frmSymbolChoice');\n    this.frmSymbolChoice.removeEventListener(\n      'change',\n      this.symbolChoiceHandler,\n    );\n    this.frmSymbolChoice.addEventListener('change', this.symbolChoiceHandler);\n    // this.menuElmAll = document.querySelectorAll('.menu__element');\n    // this.menuElmAll.forEach(elm =>\n    //   elm.removeEventListener('click', this.symbolChoiceHandler),\n    // );\n    // this.menuElmAll.forEach(elm =>\n    //   elm.addEventListener('click', this.symbolChoiceHandler),\n    // );\n    this.boardElm = document.querySelector('#boardElm');\n    this.boardCells = document.querySelectorAll('.board__cell');\n    this.initializeBoard();\n    this.drawBoard(this.board);\n  },\n\n  symbolChoiceHandler(e) {\n    log.debug(e);\n    // e.preventDefault();\n    var data = new FormData(this.frmSymbolChoice);\n    data.forEach(elm => {\n      log.debug(`User's choise: ${elm}`);\n      this.MIN = elm;\n      this.MAX = this.MIN === 'X' ? '0' : 'X';\n    });\n    this.resetBoard();\n  },\n\n  initializeBoard() {\n    document.documentElement.style.setProperty(\n      '--boardDimension',\n      this.boardDimension,\n    );\n  },\n\n  drawBoard(board) {\n    var boardHTML = board\n      .map((elm, ndx) => {\n        return `<div class=\"board__cell\" id=\"boardCellElm_${ndx}\">\n                  <span>${elm || ''}</span>\n                </div>`;\n      })\n      .join('');\n    this.addElm(this.boardElm, boardHTML);\n  },\n\n  addElm(host, elm) {\n    host.innerHTML = elm;\n    host.childNodes.forEach(child =>\n      child.addEventListener('click', this.handleClick),\n    );\n  },\n\n  stopListenElms(host) {\n    host.childNodes.forEach(child =>\n      child.removeEventListener('click', this.handleClick),\n    );\n  },\n\n  drawCell(cell, value) {\n    var cellElm = document.querySelector(`#boardCellElm_${cell}`);\n    cellElm.innerHTML = value;\n  },\n\n  handleClick(e) {\n    e.currentTarget.removeEventListener(e.type, this.handleBoardClick);\n    log.debug(`Player clicked ${e.currentTarget.id}`);\n    var move = e.currentTarget.id.split('_')[1];\n\n    if (!this.board[move]) {\n      var terminal = this.moveAndGetUtil(this.board, move, this.MIN);\n      log.debug(\n        `Condition after move to ${move} is ${\n          Boolean(terminal[0]) ? 'terminal' : 'non-terminal'\n        }`,\n      );\n\n      if (terminal[0]) this.handleTerminalConditions(terminal[1]);\n      else this.computerMove();\n    }\n  },\n};\n\nObject.assign(App, UI, Engine);\nApp.init();\nApp.listen();\nApp.start();\n\n/* 3x3 board\nX 0 _\n_ X _\n_ _ 0\n\n0 1 2\n3 4 5\n6 7 8\n\n*/\n// App.board[6] = 'X';\n// App.board[1] = '0';\n// App.board[4] = 'X';\n// App.board[5] = '0';\n\n// App.board[0] = '0';\n// App.board[1] = 'X';\n// App.board[3] = 'X';\n// App.board[4] = 'X';\n// App.board[5] = '0';\n// App.board[6] = 'X';\n// App.board[7] = '0';\nApp.drawBoard(App.board);\n\n/*\n// 4x4 board with a row and diag filled\n0 1 2 3\n4 5 6 7\n8 9 0 1\n2 3 4 5\nApp.boardDimension = 4;\nApp.board[0] = 'X';\nApp.board[3] = 'X';\nApp.board[5] = 'X';\nApp.board[7] = 'X';\nApp.board[10] = 'X';\nApp.board[11] = 'X';\nApp.board[12] = '0';\nApp.board[13] = '0';\nApp.board[14] = '0';\n\n// 4x4 board with a row and diag filled\nApp.boardDimension = 4;\nApp.board[0] = 'X';\nApp.board[3] = '0';\nApp.board[4] = 'X';\nApp.board[6] = '0';\nApp.board[8] = 'X';\nApp.board[9] = '0';\nApp.board[13] = '0';\nApp.board[14] = '0';\nApp.board[15] = '0';\n// 4x4\n// X _ _ 0\n// X _ 0 _\n// X 0 _ _\n// _ 0 0 0\n//\n*/\n"],"sourceRoot":"/source/"}